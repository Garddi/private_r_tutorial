df_example <- data.frame(names = c("Gard", "Grad", "Gard Olav", "the Notorious G.A.R.D."),
age = c(27, 23, 21, 19),
fav_movie = c("The Adolescence of Utena", "12 Angry Men", "Inception", "Straight outta Compton"),
happy = c(FALSE, TRUE, FALSE, TRUE))
df_example[1,]
df_example[c(1,2),]
df_example[,1]
df_example[,1:2]
df_example[3,2]
## Selecting on names
df_example[,c("fav_movie")]
## Index tool
df_example$age
df_example$happy
ex_list <- list(df_example, a_vector)
ex_list[[2]]
mean(a_vector)
mean(a_vector, trim = .2)
new_vector <- c(1,3,5,6,7,3,NA)
mean(new_vector)
mean(new_vector, na.rm = TRUE)
getwd()
list.files("./images/") ## ./ means the current working directory
list.files("../.")
list.files("../../advent_of_Code2022/scripts/")
## Note the file path specification is also very specific. Two dots signal
## a directory above your current. So this data is found in
## the parallell folder MA thesis, which is parallell to the folder two layers
## above the current directory, then with a specified path to find it.
library(haven)
load("../../MA thesis/Data and R scripts/Survey Data/SurvData.Rdata")
head(SurvData)
names(SurvData)
summary(SurvData$gender)
table(SurvData$gender)
table(SurvData$gender, SurvData$whostility)
class(SurvData$gender)
class(SurvData$country)
class(df_example$happy)
class(SurvData)
plot(density(SurvData$whostility))
hist(SurvData$whostility)
load("../../advanced_statistics_phd/my_data/simple_set.rda")
attributes(joined_sets2$straff)
library(tidyverse)
## A simple pipe explanation
SurvData %>%
pull(whostility) %>%
mean(na.rm = TRUE)
# Is the same as
mean(pull(SurvData, whostility), na.rm = TRUE)
library(janitor)
df_example$`This Name is REALLY bad 120` <- "BAD"
names(df_example)
df_example <- clean_names(df_example)
names(df_example)
SurvData <- SurvData %>%
mutate(gender_subtracted = gender - 1)
## Lets compare the outputs to ensure successful transformation
table(SurvData$gender, SurvData$gender_subtracted)
table(SurvData$country)
SurvData <- SurvData %>%
mutate(gender_text = as.character(gender))
class(SurvData$gender_text)
head(SurvData$gender_text)
SurvData <- SurvData %>%
mutate(gender_ifelsed = ifelse(gender == 2, "Woman", "Man"))
table(SurvData$gender, SurvData$gender_ifelsed)
SurvData <- SurvData %>%
mutate(gender_cased = case_when(  ## Style guide recomends this style
gender == 2 ~ "Woman",
gender == 1 ~ "Man",
gender == 3 ~ "Non-Binary"
))
table(SurvData$gender, SurvData$gender_cased)
vars_i <- names(joined_sets2)[16:29]
joined_sets2_mutated <- joined_sets2 %>%
mutate(across(all_of(vars_i), ~ haven::zap_labels(.x))) %>% ## Heres a fun interaction with haven...
mutate(across(all_of(vars_i), ~ ifelse(.x > 2.5, "High", "Low")))
head(joined_sets2[,16:29])
#Compared with
head(joined_sets2_mutated[,16:29])
jap_surv <- SurvData %>%
filter(country == "Japan")
jap_surv_w <- SurvData %>%
filter(country == "Japan", gender_ifelsed == "Woman")
table(jap_surv_w$country, jap_surv_w$gender_ifelsed)
women_or_japanese <- SurvData %>%
filter(country == "Japan" | gender_ifelsed == "Woman")
table(women_or_japanese$country, women_or_japanese$gender_ifelsed)
grouped_f <- SurvData %>%
mutate(whostility = ifelse(whostility < 0, NA, whostility)) %>%  # You can add the unchanged vector as a responsein an ifelse, Values less than 0 are missing categories in WVS
group_by(country, year) %>%
summarise(respondents = n(),
whostility = mean(whostility, na.rm = TRUE))
head(grouped_f)
my_vars <- c("PolDisc", "interest", "whostility")
grouped_more <- SurvData %>%
mutate(across(all_of(my_vars), ~ ifelse(.x < 0, NA, .x))) %>%
group_by(country, year) %>%
summarise(across(all_of(my_vars), ~ mean(.x, na.rm = TRUE)))
head(grouped_more)
joined_lim <- joined_sets2 %>%
mutate(eu = ifelse(eu %in% c(1,2,3,4,5), eu, NA)) %>%
select(kjonn, parti, tid, eu)
joined_lim_agg <- joined_sets2 %>%
mutate(eu = ifelse(eu %in% c(1,2,3,4,5), eu, NA)) %>%
group_by(parti, tid) %>%
summarise(mean_eu = mean(eu, na.rm = TRUE))
joined_lim[c(3,4,64,65,556,557,1231,1232,5688, 5689,6783, 6784),] ## Indexing some random rows, so we can see variance
joined_lim_joined <- joined_lim %>%
left_join(joined_lim_agg, by = c("parti", "tid")) # Here i join in the new set, i know that the parti and tid variables are in both sets
joined_lim_joined[c(3,4,64,65,556,557,1231,1232,5688, 5689,6783, 6784),] ## Indexing the same numbers
## Will limit this dataset to only a single party, and a couple of questions and key variables
## Ignore the complex code, it might make sense later
vars_i <- names(joined_sets2)[16:29] ## I know columns 16:29 are the ones I want
mean_values_for_transf <- joined_sets2 %>%
select(parti, tid, all_of(vars_i)) %>%
group_by(parti, tid) %>%
summarise(across(all_of(vars_i), ~ mean(.x, na.rm = TRUE))) %>%
pivot_longer(cols = all_of(vars_i), names_to = "question", values_to = "mean_vals")
head(mean_values_for_transf)
joined_sets2_i <-joined_sets2
joined_sets2_i$id <- 1:nrow(joined_sets2) ## If you want a fun story, ask why this is here........
new_joined <- joined_sets2_i %>%
mutate(across(all_of(vars_i), ~ haven::zap_labels(.x)),
across(all_of(vars_i), ~ ifelse(!(.x %in% c(1,2,3,4,5)), NA, .x))) %>%  ## Likert scale, so outside 1-5 is missing vals
pivot_longer(cols = all_of(vars_i), names_to = "question", values_to = "q_response") %>%
left_join(mean_values_for_transf, by = c("parti", "tid", "question")) ## Note the join so that the mean vals for the questions is there as well
dim(new_joined) ## Gets the dimensions of the object
dist_means_joined <- new_joined %>%
mutate(dist_score = q_response - mean_vals) %>%
select(-q_response, -mean_vals) %>% ### Removing these because they are reduntant and would create strange frames
pivot_wider(names_from = "question", values_from = "dist_score")
head(joined_sets2[,vars_i])
head(dist_means_joined[,vars_i])
grouped_f %>% ### Obviously you can pipe it in
ggplot(aes(x=year, y=whostility, color = country)) +
geom_point()
grouped_f %>%
ggplot(aes(x=year, y=whostility, color = country)) +
geom_point() +
theme_bw() +
labs(title = "Here's a Title", x = "Time period", y = "Anti-women sentiment", color = "Region")
grouped_f %>%
mutate(wave = case_when(             ### Mutating to better cases, so they are parallel
year == 1995 | year == 1996 ~ 1,
year == 2000 | year == 2001 ~ 2,
year == 2005 ~ 3,
year == 2010 ~ 4
)) %>%
ggplot(aes(x=wave, y = whostility, color = country)) +  ### Setting aesthetic
geom_point(size = 2) +  # Scatterplot, with 2 as size of the dots
geom_line() +          # make a line, inherits past aesthetics
theme_bw() +        # theme_bw is the best
scale_color_manual(values = c("cornflowerblue", "goldenrod")) +  ## Values are assigned alphabetically when set manually, so Japan gets first colour
labs(title = "Hostility towards women as legislators", x = "WVS Wave", y = "Hostility") ## Creating labels
plot_obj <- grouped_f %>%
mutate(wave = case_when(             ### Mutating to better cases, so they are parallel
year == 1995 | year == 1996 ~ 1,
year == 2000 | year == 2001 ~ 2,
year == 2005 ~ 3,
year == 2010 ~ 4
)) %>%
ggplot(aes(x=wave, y = whostility, color = country)) +  ### Setting aesthetic
geom_point(size = 2) +  # Scatterplot, with 2 as size of the dots
geom_line() +          # make a line, inherits past aesthetics
theme_bw() +        # theme_bw is the best
scale_color_manual(values = c("cornflowerblue", "goldenrod")) +  ## Values are assigned alphabetically when set manually, so Japan gets first colour
labs(title = "Hostility towards women as legislators", x = "WVS Wave", y = "Hostility") ## Creating labels
ggsave("plot_obj.jpeg", plot = plot_obj, device = "jpeg", path = "./images",
width = 12.5, height = 7.5)
## and now its here, contrast with earlier listes files in images
list.files("./images/")
unlink("./images/plot_obj.jpeg") ## Just removing it
library(geodata) # for gadm download
library(sf)
nor_map <- gadm(country = "NO", level = 1, path = "./") %>%
st_as_sf()
ggplot() +  ## in map data the ggplot is empty
geom_sf(data = nor_map) +
theme_void() # common theme to eliminate all lines
nor_map <- nor_map %>%
mutate(me_there = case_when(
HASC_1 == "NO.AA" ~ "Yes",
HASC_1 == "NO.AK" ~ "Home",
HASC_1 == "NO.BU" ~ "Yes",
HASC_1 == "NO.FI" ~ "No",
HASC_1 == "NO.HE" ~ "Yes",
HASC_1 == "NO.HO" ~ "Yes",
HASC_1 == "NO.MR" ~ "No",
HASC_1 == "NO.NO" ~ "No",
HASC_1 == "NO.NT" ~ "No",
HASC_1 == "NO.OF" ~ "Yes",
HASC_1 == "NO.OP" ~ "Yes",
HASC_1 == "NO.OS" ~ "Yes",
HASC_1 == "NO.RO" ~ "Yes",
HASC_1 == "NO.SF" ~ "Home",
HASC_1 == "NO.ST" ~ "Yes",
HASC_1 == "NO.TE" ~ "Yes",
HASC_1 == "NO.TR" ~ "No",
HASC_1 == "NO.VA" ~ "Yes",
HASC_1 == "NO.VF" ~ "Yes"
))
ggplot() +
geom_sf(data = nor_map, aes(fill = me_there)) +
theme_void() +
labs(title = "Mitt lille land", fill = "Have I been?") +
scale_fill_manual(values = c("goldenrod", "firebrick", "cornflowerblue"))
loopy_vector <- c(15,23,34,66,32)
for(i in 1:length(loopy_vector)){
print(loopy_vector[i]^2) ### Note that unlike outside the loop, it does not print results automatically
}
lapply(loopy_vector, FUN = function(x){ ## x serves here as our "iterator"
y <- x^2
return(y)
})
sample_nums <- c(10, 100, 1000, 10000)
lapply(sample_nums, function(x){
x_coord <- runif(x, min = 0, max = 1)    ## Randomly create coordinates in a 1x1 square
y_coord <- runif(x, min = 0, max = 1)    ## Note i use the x iterator as numbers of samples
dist <- sqrt(x_coord^2 + y_coord^2) ## Measure their distance to origin
withiners <- ifelse(dist <= 1, TRUE, FALSE)   ## If they have 1 or less in dist, they are inside the circle
pi <- (sum(withiners)*4)/x ## the share of dots inside the circle multiplied by 4 is pi
key <- paste0("Using ", x, " Samples, Pi is estimated to be ", pi, " (ish)") ## Create a return message
return(key)
}) %>% unlist() ## Unlisting the results
View(joined_sets2)
names(joined_sets2)
attributes(joined_sets2$eu)
attributes(joined_sets2$off_tjne)
attributes(joined_sets2$off_tjen)
vars_ext <- c("eu", "eea", "off_tjen", "likestilling", "left_right")
apply(joined_sets2[, vars_ext], MARGIN = 1, ## Margin argument specifies to view each extract by row or column
FUN = function(x){
opposed_eu <- ifelse(x$eu > 4, 1, 0)
opposed_eea <- ifelse(x$eea < 2, 1, 0) # This one is framed reverse
opposed_public <- ifelse(x$off_tjen > 4, 1, 0)
opposed_equal <- ifelse(x$likestilling > 4, 1, 0)
extreme <- ifelse(x$left_right > 7 | x$left_right < 3, 1, 0)
anti_val <- mean(opposed_eu, opposed_eea, opposed_public,
opposed_equal, extreme, na.rm = TRUE)
})
apply(joined_sets2[, vars_ext], MARGIN = 1, ## Margin argument specifies to view each extract by row or column
FUN = function(x){
opposed_eu <- ifelse(x[1] > 4, 1, 0)
opposed_eea <- ifelse(x[2] < 2, 1, 0) # This one is framed reverse
opposed_public <- ifelse(x[3] > 4, 1, 0)
opposed_equal <- ifelse(x[4] > 4, 1, 0)
extreme <- ifelse(x[5] > 7 | x[5] < 3, 1, 0)
anti_val <- mean(opposed_eu, opposed_eea, opposed_public,
opposed_equal, extreme, na.rm = TRUE)
})
x <- joined_sets2[1, vars_ext]
opposed_eu <- ifelse(x[1] > 4, 1, 0)
opposed_eea <- ifelse(x[2] < 2, 1, 0) # This one is framed reverse
opposed_public <- ifelse(x[3] > 4, 1, 0)
opposed_equal <- ifelse(x[4] > 4, 1, 0)
extreme <- ifelse(x[5] > 7 | x[5] < 3, 1, 0)
anti_val <- mean(opposed_eu, opposed_eea, opposed_public,
opposed_equal, extreme, na.rm = TRUE)
mean(opposed_eu, opposed_eea, opposed_public,
opposed_equal, extreme, na.rm = TRUE)
mean(opposed_eu)
mean(opposed_eea)
mean(opposed_public)
anti_val <- mean(c(opposed_eu, opposed_eea, opposed_public,
opposed_equal, extreme), na.rm = TRUE)
apply(joined_sets2[, vars_ext], MARGIN = 1, ## Margin argument specifies to view each extract by row or column
FUN = function(x){
opposed_eu <- ifelse(x[1] > 4, 1, 0)
opposed_eea <- ifelse(x[2] < 2, 1, 0) # This one is framed reverse
opposed_public <- ifelse(x[3] > 4, 1, 0)
opposed_equal <- ifelse(x[4] > 4, 1, 0)
extreme <- ifelse(x[5] > 7 | x[5] < 3, 1, 0)
anti_val <- mean(c(opposed_eu, opposed_eea, opposed_public,
opposed_equal, extreme), na.rm = TRUE)
})
joined_sets2$anti_establishment <- apply(joined_sets2[, vars_ext], MARGIN = 1, ## Margin argument specifies to view each extract by row or column
FUN = function(x){
opposed_eu <- ifelse(x[1] > 4, 1, 0)
opposed_eea <- ifelse(x[2] < 2, 1, 0) # This one is framed reverse
opposed_public <- ifelse(x[3] > 4, 1, 0)
opposed_equal <- ifelse(x[4] > 4, 1, 0)
extreme <- ifelse(x[5] > 7 | x[5] < 3, 1, 0)
anti_val <- mean(c(opposed_eu, opposed_eea, opposed_public,
opposed_equal, extreme), na.rm = TRUE)
})
table(joined_sets2$anti_establishment)
ser_acc <- httr::GET("http://api.kolada.se/v2/data/kpi/N00303/year/2022")
library(jsonlite)
fromJSON(ser_acc$conten)
fromJSON(ser_acc$content)
fromJSON(rawToChar(ser_acc$content))
test <- fromJSON(rawToChar(ser_acc$content))
test <- fromJSON(rawToChar(ser_acc$content))$dataset
test <- fromJSON(rawToChar(ser_acc$content))$values
View(test)
View(test[[4]][[1]])
View(test[[4]][[2]])
mini_test <- rawToChar(ser_acc$content)
mini_test
test <- as.data.frame(fromJSON(rawToChar(ser_acc$content)))
View(test)
test <- fromJSON(rawToChar(ser_acc$content))$values
sider <- as.data.frame(test$values)
View(sider)
sider <- unlist(test$values)
length(test$values[1])
length(test$values[2])
length(test$values[2])
length(test$values)
class(test$values)
test$values
sider <- bind_rows(test$values)
View(sider)
??content
test <- httr::content(ser_acc)
View(test)
test2 <- as.data.frame(test$values)
test2 <- test$values
View(test2)
View(test2)
test <- fromJSON(rawToChar(ser_acc$content))$values
ser_acc_final <- test %>%
select(-values) %>%
cbind(sider)
View(ser_acc_final)
test <- httr::content(ser_acc)$values
View(test)
test <- httr::content(ser_acc)$values %>%
as.data.frame()
test <- httr::content(ser_acc)$values %>%
bind_rows()
View(test[[4]][[325]])
sample_nums <- c(10, 100, 1000, 10000)
lapply(sample_nums, function(x){
x_coord <- runif(x, min = 0, max = 1)    ## Randomly create coordinates in a 1x1 square
y_coord <- runif(x, min = 0, max = 1)    ## Note i use the x iterator as numbers of samples
dist <- sqrt(x_coord^2 + y_coord^2) ## Measure their distance to origin
withiners <- ifelse(dist <= 1, TRUE, FALSE)   ## If they have 1 or less in dist, they are inside the circle
pi <- (sum(withiners)*4)/x ## the share of dots inside the circle multiplied by 4 is pi
key <- paste0("Using ", x, " Samples, Pi is estimated to be ", pi, " (ish)") ## Create a return message
return(key)
}) %>% unlist() ## Unlisting the results
lapply(sample_nums, function(x){
x_coord <- runif(x, min = 0, max = 1)    ## Randomly create coordinates in a 1x1 square
y_coord <- runif(x, min = 0, max = 1)    ## Note i use the x iterator as numbers of samples
dist <- sqrt(x_coord^2 + y_coord^2) ## Measure their distance to origin
withiners <- ifelse(dist <= 1, TRUE, FALSE)   ## If they have 1 or less in dist, they are inside the circle
pi <- (sum(withiners)*4)/x ## the share of dots inside the circle multiplied by 4 is pi
key <- paste0("Using ", x, " Samples, Pi is estimated to be ", pi, " (ish)") ## Create a return message
return(key)
}) %>% unlist() ## Unlisting the results
lapply(sample_nums, function(x){
x_coord <- runif(x, min = 0, max = 1)    ## Randomly create coordinates in a 1x1 square
y_coord <- runif(x, min = 0, max = 1)    ## Note i use the x iterator as numbers of samples
dist <- sqrt(x_coord^2 + y_coord^2) ## Measure their distance to origin
withiners <- ifelse(dist <= 1, TRUE, FALSE)   ## If they have 1 or less in dist, they are inside the circle
pi <- (sum(withiners)*4)/x ## the share of dots inside the circle multiplied by 4 is pi
key <- paste0("Using ", x, " Samples, Pi is estimated to be ", pi, " (ish)") ## Create a return message
return(key)
}) %>% unlist() ## Unlisting the results
sample_nums <- c(10, 100, 1000, 10000, 100000)
lapply(sample_nums, function(x){
x_coord <- runif(x, min = 0, max = 1)    ## Randomly create coordinates in a 1x1 square
y_coord <- runif(x, min = 0, max = 1)    ## Note i use the x iterator as numbers of samples
dist <- sqrt(x_coord^2 + y_coord^2) ## Measure their distance to origin
withiners <- ifelse(dist <= 1, TRUE, FALSE)   ## If they have 1 or less in dist, they are inside the circle
pi <- (sum(withiners)*4)/x ## the share of dots inside the circle multiplied by 4 is pi
key <- paste0("Using ", x, " Samples, Pi is estimated to be ", pi, " (ish)") ## Create a return message
return(key)
}) %>% unlist() ## Unlisting the results
names(SurvData)
SurvData$interest + SurvData$PolDisc
length(SurvData$interest + SurvData$PolDisc)
(SurvData$interest + SurvData$PolDisc)[1] == SurvData$interest[1] + SurvData$PolDisc[1]
(SurvData$interest + SurvData$PolDisc)[2534] == SurvData$interest[2534] + SurvData$PolDisc[2534]
(SurvData$interest + SurvData$PolDisc)[2535] == SurvData$interest[2535] + SurvData$PolDisc[2535]
(SurvData$interest + SurvData$PolDisc)[5098] == SurvData$interest[5098] + SurvData$PolDisc[5098]
(SurvData$interest + SurvData$PolDisc)[8092] == SurvData$interest[8092] + SurvData$PolDisc[8092]
SurvData$pol_index <- (SurvData$PolDisc + SurvData$interest)/2 ## Making the mean out of the two
summary(SurvData$pol_index)
Sys.setlocale()
names(SurvData) ## Note which variables I do have
SurvData_sub <- SurvData %>%
select(country, gender, whostility)
names(SurvData_sub)
SurvData_sub <- SurvData %>%
select(-PolDisc, -interest)
names(SurvData_sub)
vars_i_want <- c("gender", "country", "whostility")
SurvData_sub <- SurvData %>%
select(all_of(vars_i_want))
names(SurvData_sub)
SurvData_sub <- SurvData %>%
select(starts_with("gender"))
names(SurvData_sub)
plot(density(SurvData$PolDisc, SurvData$interest))
plot(density(c(SurvData$PolDisc, SurvData$interest)))
plot(density(SurvData$PolDisc))
plot(density(SurvData$whostility))
plot(density(SurvData$gender))
plot(density(SurvData$whostility, SurvData$gender))
plot(density(c(SurvData$whostility, SurvData$gender)))
density(SurvData$whostility, SurvData$gender)
ggplot(SurvData, aes(x=whostility, y = PolDisc)) + geom_density_2d()
nor_map_int <- ggplot() +
geom_sf(data = nor_map, aes(fill = me_there)) +
theme_void() +
labs(title = "Mitt lille land", fill = "Have I been?") +
scale_fill_manual(values = c("goldenrod", "firebrick", "cornflowerblue"))
plotly::ggplotly(nor_map_int)
nor_map_int
plotly::ggplotly(nor_map_int)
nor_map_int <- ggplot() +
geom_sf(data = nor_map, aes(geometry = geometry, fill = me_there)) +
theme_void() +
labs(title = "Mitt lille land", fill = "Have I been?") +
scale_fill_manual(values = c("goldenrod", "firebrick", "cornflowerblue"))
plotly::ggplotly(nor_map_int)
ggplot() +
geom_sf(data = nor_map, aes(geometry = geometry, fill = me_there)) +
theme_void() +
labs(title = "Mitt lille land", fill = "Have I been?") +
scale_fill_manual(values = c("goldenrod", "firebrick", "cornflowerblue"))
library(plotly)
ggplotly(nor_map_int)
plot_ly(nor_map_int)
plot_ly(nor_map)
class(nor_map)
class(nor_map$geometry)
new_map <- sf::st_cast(nor_map, "MULTIPOLYGON")
nor_map_int <- ggplot() +
geom_sf(data = new_map, aes(geometry = geometry, fill = me_there)) +
theme_void() +
labs(title = "Mitt lille land", fill = "Have I been?") +
scale_fill_manual(values = c("goldenrod", "firebrick", "cornflowerblue"))
ggplotly(nor_map_int)
?is.numeric
plotly::ggplotly(nor_map_int)
df_example$names
df_example$names[3]
df_example$fav_movie[3]
df_example$fav_movie[4]
df_example$fav_movie[1]
df_example$names[idx]
df_example$happy[idx]
idx <- 3 # idx for indexer
df_example$names[idx]
idx <- c(1,3)
df_example$names[idx]
df_example$fav_movie[idx]
?stop
cat("hello")
cat("hello\n")
names(SurvData)
model_1 <- lm(whostility ~ gender_text + country + year + PolDisc + interest, data = SurvData)
summary(model_1)
SurvData <- SurvData %>%
mutate(wave = case_when( ## Just using year will give a strange intercept
year == 1995 | year == 1996 ~ 1,
year == 2000 | year == 2001 ~ 2,
year == 2005 ~ 3,
year == 2010 ~ 4
))
model_1 <- lm(whostility ~ gender_text + country + wave + PolDisc + interest, data = SurvData)
summary(model_1)
model_2 <- lm(whostility ~ gender_text + country + wave + PolDisc + interest + country*gender_text, data = SurvData)
summary(model_2)
summary(SurvData$voted)
table(SurvData$voted, SurvData$year)
?tryCatch
?invokeRestart
?try
1%%2
10%%2
numbers <- c(1:10)
for(i in 1:length(numbers)){
if(numbers[i] %% 2 == 0){
print(paste0("This number: ", numbers[i], ", is even!"))
}else{
print(paste0("This number: ", numbers[i], ", is odd!"))
}
}
while(iter < 15){
print(paste0("iterator is now: ", iter, "!"))
iter <- iter + 1
}
iter <- 1
while(iter < 15){
print(paste0("iterator is now: ", iter, "!"))
iter <- iter + 1
}
iter <- 1
while(iter < 15){
print(paste0("iterator is now: ", iter, "!"))
iter <- iter + 1
if(iter == 12){
print(paste0("oh no, iterator ", iter, "broke the loop! :("))
break
}
}
iter <- 1
repeat{
print(paste0("iterator is now: ", iter, "!"))
iter <- iter + 1
if(iter == 12){
print(paste0("oh no, iterator ", iter, " broke the loop! :("))
break
}
}
